<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <link
      rel="apple-touch-icon"
      type="image/png"
      href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png"
    />
    <meta name="apple-mobile-web-app-title" content="CodePen" />

    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico"
    />

    <link
      rel="mask-icon"
      type="image/x-icon"
      href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg"
      color="#111"
    />

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>CodePen - Particle Text</title>

    <link
      rel="stylesheet"
      media="screen"
      href="https://cpwebassets.codepen.io/assets/fullpage/fullpage-1580f96ce81ff0a427cf57dda2748ce646c38efc201ae5942a29958cffa6856d.css"
    />

    <link
      rel="apple-touch-icon"
      type="image/png"
      href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png"
    />
    <meta name="apple-mobile-web-app-title" content="CodePen" />

    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico"
    />

    <link
      rel="mask-icon"
      type="image/x-icon"
      href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg"
      color="#111"
    />

    <title>CodePen - Particle Text</title>
    <script>
      if (document.location.search.match(/type=embed/gi)) {
        window.parent.postMessage("resize", "*");
      }
    </script>

    <style>
      html {
        font-size: 15px;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        min-height: 100%;
      }
      body {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      .referer-warning {
        background: black;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        padding: 0.75em;
        color: white;
        text-align: center;
        font-family: var(--cp-font-family);
        line-height: 1.2;
        font-size: 1rem;
        position: relative;
        z-index: 2;
      }
      .referer-warning h1 {
        font-size: 1.2rem;
        margin: 0;
      }
      .referer-warning a {
        color: #56bcf9;
      } /* $linkColorOnBlack */
    </style>
  </head>

  <body class="">
    <!-- <div class="referer-warning">
      <h1>
        ⚠️ Do not enter passwords or personal information on this page. ⚠️
      </h1>
      This is a code demo posted by a web developer on
      <a href="https://codepen.io">codepen.io</a>.
      <br />
      A referer from CodePen is required to render this page view, and your
      browser is not sending one (<a
        href="https://blog.codepen.io/2017/10/05/regarding-referer-headers/"
        target="_blank"
        >more details</a
      >).
    </div> -->

    <div id="result-iframe-wrap" role="main">
      <iframe
        id="result"
        srcdoc='
  <!DOCTYPE html>
  <html lang="en" >
  
  <head>
  
    <meta charset="UTF-8">
    
  <link rel="apple-touch-icon" type="image/png" href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png" />
  <meta name="apple-mobile-web-app-title" content="CodePen">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico" />
  
  <link rel="mask-icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg" color="#111" />
  
  
    <title>CodePen - Particle Text</title>
    <link href="https://fonts.googleapis.com/css?family=Oswald&amp;display=swap" rel="stylesheet">
  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
  
    
    
  <style>
  html, body {
    height: 100%;
    background: black;
  }
  </style>
  
    <script>
    window.console = window.console || function(t) {};
  </script>
  
    
    
    <script>
    if (document.location.search.match(/type=embed/gi)) {
      window.parent.postMessage("resize", "*");
    }
  </script>
  
  
  </head>
  
  <body translate="no" >
    
      <script src="https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-1b93190375e9ccc259df3a57c1abc0e64599724ae30d7ea4c6877eb615f89387.js"></script>
  
    <script src=&apos;https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js&apos;></script>
  <script src=&apos;https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js&apos;></script>
        <script id="rendered-js" >
  "use strict";
  
  const {
    abs,
    acos,
    asin,
    atan,
    atan2,
    ceil,
    cos,
    max,
    min,
    PI,
    pow,
    random,
    round,
    sin,
    sqrt,
    tan } =
  Math;
  const HALF_PI = 0.5 * PI;
  const QUART_PI = 0.25 * PI;
  const TAU = 2 * PI;
  const TO_RAD = PI / 180;
  const G = 6.67 * pow(10, -11);
  const EPSILON = 2.220446049250313e-16;
  const rand = n => n * random();
  const randIn = (_min, _max) => rand(_max - _min) + _min;
  const randRange = n => n - rand(2 * n);
  const fadeIn = (t, m) => t / m;
  const fadeOut = (t, m) => (m - t) / m;
  const fadeInOut = (t, m) => {
    let hm = 0.5 * m;
    return abs((t + hm) % m - hm) / hm;
  };
  const dist = (x1, y1, x2, y2) => sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
  const angle = (x1, y1, x2, y2) => atan2(y2 - y1, x2 - x1);
  const lerp = (a, b, t) => (1 - t) * a + t * b;
  const clamp = (n, _min, _max) => min(max(n, _min), _max);
  const norm = (n, _min, _max) => (n - _min) / (_max - _min);
  const floor = n => n | 0;
  const fract = n => n - floor(n);
  const vh = p => p * window.innerHeight * 0.01;
  const vw = p => p * window.innerWidth * 0.01;
  const vmin = p => min(vh(p), vw(p));
  const vmax = p => max(vh(p), vw(p));
  const intToRGBA = n => {
    let r, g, b, a;
  
    n >>>= 0;
  
    r = (n &amp; 0xff000000) >>> 24;
    g = (n &amp; 0xff0000) >>> 16;
    b = (n &amp; 0xff00) >>> 8;
    a = (n &amp; 0xff) / 255;
  
    return `rgba(${[r, g, b, a].join()})`;
  };
  const nearestMultiple = (n, d) => n - n % d;
  const drawTypes = {
    FILL: "fill",
    STROKE: "stroke" };
  
  const textAlignTypes = {
    CENTER: "center",
    END: "end",
    LEFT: "left",
    RIGHT: "right",
    START: "start" };
  
  const textBaselineTypes = {
    ALPHABETIC: "alphabetic",
    BOTTOM: "bottom",
    HANGING: "hanging",
    MIDDLE: "middle",
    TOP: "top" };
  
  
  const debounce = (fn, wait = 200) => {
    let timeout;
  
    return (...args) => {
      if (timeout) clearTimeout(timeout);
  
      timeout = setTimeout(() => fn(...args), wait);
    };
  };
  
  Array.prototype.lerp = function (t = [], a = 0) {
    this.forEach((n, i) => this[i] = lerp(n, t[i], a));
  };
  
  Float32Array.prototype.get = function (i = 0, n = 0) {
    return this.slice(i, i + n);
  };
  
  class PropsArray {
    constructor(count = 0, props = [], type = "float") {
      this.count = count;
      this.props = props;
      this.spread = props.length;
      this.values =
      type === "float" ?
      new Float32Array(count * props.length) :
      new Uint32Array(count * props.length);
    }
    get length() {
      return this.values.length;
    }
    set(a = [], i = 0) {
      this.values.set(a, i);
    }
    setMap(o = {}, i = 0) {
      this.set(Object.values(o), i);
    }
    get(i = 0) {
      return this.values.get(i, this.spread);
    }
    getMap(i = 0) {
      return this.get(i).reduce((r, v, i) => {
        r[this.props[i]] = v;
  
        return r;
      }, {});
    }
    forEach(cb) {
      let i = 0;
  
      for (; i < this.length; i += this.spread) {
        cb(this.get(i), i, this);
      }
    }
    map(cb) {
      let i = 0;
  
      for (; i < this.length; i += this.spread) {
        this.set(cb(this.get(i), i, this), i);
      }
    }
    async *read() {
      let i = 0;
  
      for (; i < this.length; i += this.spread) {
        yield { index: i, value: this.get(i) };
      }
    }}
  
  
  function createOffscreenCanvas(width, height) {
    let _canvas;
  
    if (typeof OffscreenCanvas !== "undefined") {
      _canvas = new OffscreenCanvas(parseFloat(width), parseFloat(height));
    } else {
      _canvas = createCanvas(width, height);
    }
  
    return _canvas;
  }
  
  function createCanvas(width, height) {
    const canvas = document.createElement("canvas");
  
    canvas.width = width;
    canvas.height = height;
  
    return canvas;
  }
  
  function createContext2D(
  width = innerWidth,
  height = innerHeight,
  contextAttributes)
  {
    return createCanvas(width, height).getContext("2d", contextAttributes);
  }
  
  function createOffscreenContext2D(
  width = innerWidth,
  height = innerHeight,
  contextAttributes)
  {
    return createOffscreenCanvas(width, height).getContext(
    "2d",
    contextAttributes);
  
  }
  
  function createRenderingContext(width, height) {
    const contextAttributes = {
      alpha: true,
      desynchronized: true };
  
  
    const ctx = createContext2D(width, height, contextAttributes);
    const buffer = createOffscreenContext2D(width, height, contextAttributes);
  
    ctx.canvas.style.position = "absolute";
    ctx.canvas.style.top = "0";
    ctx.canvas.style.left = "0";
  
    document.body.appendChild(ctx.canvas);
  
    return {
      buffer,
      ctx };
  
  }
  const options = {
    mouse: {
      lerpAmt: 0.5,
      repelThreshold: 100 },
  
    particles: {
      density: 3,
      get pixelDensity() {
        return (4 - this.density) * 4;
      },
      pLerpAmt: 0.25,
      vLerpAmt: 0.1 },
  
    text: {
      drawType: drawTypes.STROKE,
      fontColor: [60, 200, 255, 255],
      fontSize: 100,
      get fontStyle() {
        return `${this.fontSize}px Oswald, sans-serif`;
      },
      message: &apos;Happy birthday to Aisha ;) from Danish&apos; } };
  
  
  const particleProps = [
  &apos;x&apos;,
  &apos;y&apos;,
  &apos;vx&apos;,
  &apos;vy&apos;,
  &apos;bx&apos;,
  &apos;by&apos;];
  
  const { buffer, ctx } = createRenderingContext();
  
  // Utils: https://codepen.io/seanfree/pen/LvrJWz
  
  let hover = false;
  let userx = 0;
  let usery = 0;
  let repelx = 0;
  let repely = 0;
  let centerx = 0;
  let centery = 0;
  let particles;
  let width;
  let height;
  let imageBuffer;
  let gui;
  let stats;
  
  window.addEventListener(&apos;resize&apos;, setup);
  window.addEventListener(&apos;mousemove&apos;, mousemove);
  window.addEventListener(&apos;mouseout&apos;, mousemove);
  window.addEventListener(&apos;load&apos;, start);
  
  function start() {
    createStats();
    createGUI();
    setup();
    run();
  }
  
  function setup() {
    resize();
    clearBuffer();
    setTextStyles();
    mapParticles();
  }
  
  function run() {
    requestAnimationFrame(run);
  
    stats.begin();
  
    update();
    render();
  
    stats.end();
  }
  
  function update() {
    if (hover) {
      repelx = lerp(repelx, userx, options.mouse.lerpAmt);
      repely = lerp(repely, usery, options.mouse.lerpAmt);
    } else {
      repelx = lerp(repelx, centerx, options.mouse.lerpAmt);
      repely = lerp(repely, centery, options.mouse.lerpAmt);
    }
  }
  
  function render() {
    clearBuffer();
    clearScreen();
    drawParticles();
    renderFrame();
  }
  
  function mapParticles() {
    drawMessage();
  
    const pixelData = new Uint32Array(buffer.getImageData(0, 0, width, height).data);
    const pixels = [];
  
    let i, x, y, bx, by, vx, vy;
  
    for (i = 0; i < pixelData.length; i += 4) {
      if (pixelData[i + 3] &amp;&amp; !(i % options.particles.pixelDensity)) {
        x = rand(width) | 0;
        y = rand(height) | 0;
        bx = i / 4 % width;
        by = i / 4 / width | 0;
        vx = 0;
        vy = 0;
  
        pixels.push(x, y, vx, vy, bx, by);
      }
    }
  
    particles = new PropsArray(pixels.length / particleProps.length, particleProps);
    particles.set(pixels, 0);
  }
  
  function drawParticles() {
    let i, index, x, _x, y, _y, vx, vy, bx, by;
  
    imageBuffer.data.fill(0);
  
    particles.forEach(([x, y, vx, vy, bx, by], index) => {
      _x = x | 0;
      _y = y | 0;
  
      if (!outOfBounds(_x, _y, width, height)) {
        i = 4 * (_x + _y * width);
  
        fillPixel(imageBuffer, i, options.text.fontColor);
      }
  
      particles.set(updatePixelCoords(x, y, vx, vy, bx, by), index);
    });
  
    buffer.putImageData(imageBuffer, 0, 0);
  }
  
  function fillPixel(imageData, i, [r, g, b, a]) {
    imageData.data.set([r, g, b, a], i);
  }
  
  function updatePixelCoords(x, y, vx, vy, bx, by) {
    let rd, dx, dy, phi, f;
  
    rd = dist(x, y, repelx, repely);
  
    phi = angle(repelx, repely, x, y);
    f = pow(options.mouse.repelThreshold, 2) / rd * (rd / options.mouse.repelThreshold);
  
    dx = bx - x;
    dy = by - y;
  
    vx = lerp(vx, dx + cos(phi) * f, options.particles.vLerpAmt);
    vy = lerp(vy, dy + sin(phi) * f, options.particles.vLerpAmt);
  
    x = lerp(x, x + vx, options.particles.pLerpAmt);
    y = lerp(y, y + vy, options.particles.pLerpAmt);
  
    return [x, y, vx, vy];
  }
  
  function outOfBounds(x, y, width, height) {
    return x < 1 || x >= width || y < 1 || y >= height;
  }
  
  function renderFrame() {
    ctx.save();
  
    ctx.filter = &apos;blur(8px) brightness(200%)&apos;;
    ctx.drawImage(buffer.canvas, 0, 0);
  
    ctx.filter = &apos;blur(0)&apos;;
    ctx.globalCompositeOperation = &apos;lighter&apos;;
    ctx.drawImage(buffer.canvas, 0, 0);
  
    ctx.restore();
  }
  
  function clearScreen() {
    clear(ctx);
  }
  
  function clearBuffer() {
    clear(buffer);
  }
  
  function clear(_ctx) {
    _ctx.clearRect(0, 0, _ctx.canvas.width, _ctx.canvas.height);
  }
  
  function drawMessage() {
    drawText(
    options.text.message,
    centerx,
    centery,
    options.text.drawType);
  
  }
  
  function setTextStyles() {
    setFont(options.text.fontStyle);
    setTextBaseline(textBaselineTypes.MIDDLE);
    setTextAlign(textAlignTypes.CENTER);
  }
  
  function drawText(str = &apos;&apos;, x = 0, y = 0, type = drawTypes.FILL) {
    buffer[`${type}Text`](str, x, y);
  }
  
  function setFont(font) {
    buffer.font = font;
  }
  
  function setTextAlign(align = textAlignTypes.LEFT) {
    buffer.textAlign = align;
  }
  
  function setTextBaseline(baseline = textBaselineTypes.ALPHABETIC) {
    buffer.textBaseline = baseline;
  }
  
  function resize() {
    buffer.canvas.width = width = innerWidth;
    buffer.canvas.height = height = innerHeight;
  
    buffer.drawImage(ctx.canvas, 0, 0);
  
    ctx.canvas.width = innerWidth;
    ctx.canvas.height = innerHeight;
  
    ctx.drawImage(buffer.canvas, 0, 0);
  
    centerx = 0.5 * innerWidth;
    centery = 0.5 * innerHeight;
  
    imageBuffer = buffer.createImageData(width, height);
  }
  
  function mousemove({ type, clientX, clientY }) {
    hover = type === &apos;mousemove&apos;;
    userx = clientX;
    usery = clientY;
  }
  
  function createStats() {
    stats = new Stats();
    document.body.appendChild(stats.domElement);
    stats.domElement.style.position = &apos;absolute&apos;;
  }
  
  function createGUI() {
    gui = new dat.GUI();
  
    addTextOptions();
    addMouseOptions();
    addParticleOptions();
  }
  
  function addTextOptions() {
    const textFolder = gui.addFolder(&apos;text&apos;);
  
    textFolder.add(options.text, &apos;drawType&apos;, Object.values(drawTypes)).
    onFinishChange(setup);
    textFolder.addColor(options.text, &apos;fontColor&apos;);
    textFolder.add(options.text, &apos;fontSize&apos;, 20, 200).
    onFinishChange(setup);
    textFolder.add(options.text, &apos;message&apos;).
    onFinishChange(setup);
  
    textFolder.open();
  }
  
  function addMouseOptions() {
    const mouseFolder = gui.addFolder(&apos;mouse&apos;);
  
    mouseFolder.add(options.mouse, &apos;lerpAmt&apos;, 0.05, 1);
    mouseFolder.add(options.mouse, &apos;repelThreshold&apos;, 20, 200);
  
    mouseFolder.open();
  }
  
  function addParticleOptions() {
    const particlesFolder = gui.addFolder(&apos;particles&apos;);
  
    particlesFolder.add(options.particles, &apos;density&apos;, 1, 4, 1).
    onFinishChange(setup);
    particlesFolder.add(options.particles, &apos;pLerpAmt&apos;, 0.05, 1).
    onFinishChange(setup);
    particlesFolder.add(options.particles, &apos;vLerpAmt&apos;, 0.05, 1).
    onFinishChange(setup);
  
    particlesFolder.open();
  }
  //# sourceURL=pen.js
      </script>
  
    
  
  </body>
  
  </html>
   
  '
        sandbox="allow-downloads allow-forms allow-modals allow-pointer-lock allow-popups allow-presentation  allow-scripts allow-top-navigation-by-user-activation"
        allow="accelerometer; camera; encrypted-media; display-capture; geolocation; gyroscope; microphone; midi; clipboard-read; clipboard-write; web-share"
        allowtransparency="true"
        allowpaymentrequest="true"
        allowfullscreen="true"
        class="result-iframe"
      >
      </iframe>
    </div>
  </body>
</html>
